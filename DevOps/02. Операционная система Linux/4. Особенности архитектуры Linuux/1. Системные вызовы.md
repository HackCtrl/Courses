***У ядра Linux две основные функции:*** контроль доступа и управление ресурсами (дисками, памятью, процессором и сетью)

*Чтобы программы могли работать с файлами на жестком диске, использовать сетевые адаптеры и другие аппаратные составляющие, существуют* **системные вызовы** 
## ***Пользователи: какими и каких типов бывают вызовы***

***Вызовы и процессы - есть два вида:*** 
- Синхронные (не запустится, пока не завершится предыдущая)
- Асинхронные (могут выполняться и вызываться, не ожидая завершения предыдущих)

***У вызовов есть категории. Каждая категория управляет чем то конкретным:*** 
1. Управление процессами 
2. Управление файлами 
3. Управление устройствами 
4. Управление системной информацией 
5. Управление взаимодействием  процессов 
6. Контроль доступа 

![[Pasted image 20251113191854.png]]
*Работа пользователя с системой, чтение содержимого файла* 
## ***Процессы и системные вызовы***

***Родительский процесс*** - это процесс, который запускает дополнительные процессы, еще их называют дочерними

`top` - команды для определения, жив ли процесс, запущен ли, сколько требует ресурсов 
![[Pasted image 20251113192253.png]]
- `PID` **(Process ID — «уникальный номер процесса»)** - параметр, благодаря которому система может управлять процессами 
- `USER` - пользователь, от которого выполняется текущий процесс 
- `COMMAND` - инструкции, выполняемые процессом

***Чтобы выполнить операцию, которая требует повышения привилегий или доступа к системным ресурсам:*** 
1. Процесс вызывает функцию - запрос в ОС 
2. Затем выполняет специальную инструкцию процессов 
3. Переключается в привилегированный режим, вызывает функцию ядра и передает ей управление 
4. Если все в порядке, функция выполняет задачи и возвращает управление процессу 

***Таким образом в системе есть два пространства - пользовательское и ядра:*** 
![[Pasted image 20251113192838.png]]

***Вызовы:*** 
![[Pasted image 20251113192923.png]]

![[Pasted image 20251113192938.png]]

***Получается следующее:***
1. Пользователь создаёт родительский процесс.
2. Родительский процесс делает `fork()` и создаёт дочерний процесс на чтение диска — если он доступен — и выгружает в память прочитанное.
3. Процесс чтения диска запускает `fork()`, который с помощью вызова `stat()` создаёт процесс проверки существования файла и наличия доступа у пользователя.
4. Если с правами всё хорошо, запускается `fork()` на создание процесса чтения файла и через `close()` завершается процесс проверки прав доступа и существования файла.
5. Процесс чтения файла делает вызов `read()`, загружает данные в память с помощью `mmap()` и отдаёт родительскому процессу полученное содержимое файла.
6. Все незакрытые процессы закрываются с помощью `close()`.

