## ***Что такое процесс***

***Процесс*** - это выполняющаяся программа 

***Пример:*** 
- Процесс - это повар, который готовит блюдо 
- ОС - это кухня, которая обеспечивает всех необходимыми ресурсами 

***Процесс работает:*** 
- С памятью - данными, которые он использует 
- Ресурсами - доступ к сети или файлам
- Инструкциями - кодом, который процесс выполняет 

*Каждый процесс имеет свой уникальный идентификатор (PID)*
## ***Процесс и нити, или потоки***

***Нить, или поток*** - это единица выполнения внутри процесса. Каждый процесс может иметь одну или несколько нитей. Все нити внутри процесса используют общую память, но каждая нить выполняет свою задачу. Многозадачность внутри одного процесса реализуется через использование многоситовых программ 

***Пример:*** 
- Процесс - это повар (основная задача)
- Нити - это помощники, которые работают над частями задачи (многозадачность внутри процесса)

***Многопроцессность*** - когда несколько процессов выполняются одновременно. Каждый процесс имеет свою память и ресурсы 

***Многонитевость*** - когда один процесс разделяет свою задачу на несколько частей, которые выполняются параллельно, деля ресурсы 
## ***Дерево процессов***

***Процессы в Linux формируют дерево процессов. У каждого процесса есть родитель, и процессы могут создавать дочерние процессы (в ресторане повар может обучать новых поваров - это дочерние процессы). В итоге все процессы образуют дерево, начиная с процесса systemd (PID 1):*** 
`systemd (PID 1)`

`├── bash (PID 123)`

`├── apache2 (PID 124)`

`└── mysql (PID 125)>`
#### ***Как просмотреть дерево процессов***

`pstree` - команда для просмотра дерева процессов 
`ps -e --forest` - команда для мониторинга процессов, чтобы увидеть дерево процессов с иерархией 
## ***Порождение процессов с помощью `fork()`***

`fork()` - это системный вызов, который позволяет создавать новый процесс 

***Пример кода на Python:***

```
import os

pid = os.fork()

if pid < 0:

# Ошибка при создании дочернего процесса

print("Ошибка при создании процесса")

exit(1)

if pid == 0:

# Дочерний процесс

print(f"Дочерний процесс: PID = {os.getpid()}, PPID = {os.getppid()}")

else:

# Родительский процесс

print(f"Родительский процесс: PID = {os.getpid()}, дочерний процесс PID = {pid}") 
```

***Как это работает:***

1. Когда вызывается os.fork(), родительский процесс продолжает выполнение и получает PID дочернего процесса
2. Дочерний процесс получает значение 0 и выполняет свой код 
3. os.getpid() возвращает PID текущего процесса, а os.getppid() - PID родительского процесса 

***Зачем это нужно:***
- Создание параллельных процессов 
- Разделение задач
- Работа с серверами 

***Что происходит в памяти при вызове `fork()`:***
Создается копия данных родительского процесса, включая стек, кучу и данные. Однако на самом деле данные не копируются немедленно. Вместо этого используется механизм copy-on-write (COW)

***Copy-on-Write (COW)*** - позволяет экономить память, создавая копию данных только в том случае, если родительский или дочерний процесс изменяет часть памяти 
## ***Атрибуты процесса***

- **PID** (Process ID) - уникальный идентификатор процесса 
- **PPID** (Parent Process ID) - идентификатор родительского процесса 
- **UID** (User ID) - идентификатор пользователя, который запустил процесс 
- **GID** (Group ID) - идентификатор группы 
- **ресурсы** - процесс использует определённую часть процессора (%CPU), памяти (%MEM) и времени (TIME)
- **состояние** (STAT) - процесс может быть «спящим» (S), выполняющимся (R), завершённым (Z) и так далее

***ps*** - команда для просмотра процессов и их атрибутов: 
- `ps aux` - выведет все процессы 
- `ps -ef` - отобразит информацию о процессах в более удобочитаемом виде 
- `ps -e --forest` - построит дерево процессов

***Состояние процессов:*** 
- **`R`** (от англ. running или runnable) «активен» - процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выполнение очередного количества процессного времени 
- **`S`** (от англ. sleeping) «спит» - находится в состоянии ожидания менее 20 секунд, то есть ждет какого-то события, сигнала или освобождения нужного ресурса 
- **`I`** (от англ. idle ) «бездействует» - находится в состоянии ожидания более 20 секунд 
- **`D`** (от англ. direct) «прямой» - находится в состоянии непрерывного ожидания "прямого" сигнала от аппаратной части и не реагирует на другие сигналы 
- **`Т`** (от англ. stopped) «приостановлен» - находится в режиме трассировки (обычно при откладке программ)
- **`Z`** (от англ. zombie) «зомби» - это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освободились 
## ***Управление процессами***

#### ***Завершение процесса***

`kill` - команда для завершения процесса: 
- `kill <PID>`
`9` - сигнал для принудительного завершения процесса: 
- `kill -9 <PID>`
`killall` - для завершения нескольких процессов с одним и тем же названием: 
- `killall <name_proc>`
`9` - для принудительного завершения: 
- `killall -s 9 <name_proc>`
#### ***Мониторинг процессов***

`top` - для мониторинга процессов в реальном времени 

***LA — Load Average*** (в утилите top/htop) - это показатель средней нагрузки на процессор, точнее количество процессов, ожидающих выполнение 

*На собеседованиях любят задавать вопросы про LA, причём формулировки могут быть с подвохом, например: «LA около 30 — это много или мало?» Мы бы уточнили: «А сколько ядер в системе?»*
#### ***Запуск процесса в фоновом режиме***

`&` - чтобы запустить процесс в фоновом режиме: 
- `sleep 60 &`(Эта команда запустит `sleep` (паузу на 60 секунд) в фоновом режиме и выведет в консоль PID запущенного процесса)
#### ***Управление приоритетом***

***NI*** (в утилите top/htop) - понятие вежливость. В Linux-системах более приоритетные задачи считаются менее «вежливыми», потому что «нагло» забирают ресурсы себе. А менее приоритетные «вежливо» ждут, когда ресурсы освободятся. Его значение по умолчанию равно 0, но на деле может варьироваться от −20 (наибольший приоритет) до 20 (наименьший приоритет).

`renice` - команда для изменения показателя вежливости: 
- `renice -n 1 -p 1234`(В данном примере мы изменяем значение вежливости процесса (PID = 1234) на `1`)
`-u` - флаг для изменения приоритета для всех процессов определенного пользователя: 
- `renice -n 1 -u student`
## ***Привилегии процессов***

#### ***Как процессы получают привилегии***

*Они наследуют их за пользователем, который их запустил* 
#### ***Как привилегии процесса влияют на безопасность***

*Процесс, запущенный с правами root, может повредить систему или установить вредоносное ПО, если будет скомпрометирован.
#### ***Проверка привилегий процесса***

***Чтобы проверить, с какими правами работает процесс, можно использовать команду `ps` с флагом `-o` для отображения UID (User ID) и GID (Group ID):***
- `ps -o pid,uid,gid,comm`
#### ***Системный вызов `setuid()`***

*Позволяет процессу изменить свой идентификатор пользователя (UID). С помощью этого вызова процесс может повысить или понизить свои привилегии* 

***Пример на Python:*** 

```
import os

os.setuid(0)  # Устанавливаем UID процесса в 0 (root) 
```

