***Dockerfile*** - это необязательное условие для запуска контейнера: он нужен, чтобы настроить будущий образ. Но если нас устраивает дефолтное состояние и минимальный набор параметров, можно добавить их сращу в командную строку 

***У Dockerfile есть свои преимущества:*** 
- Гибкость 
- Воспроизводимость 
- Управление версиями 

*Запуск контейнера без Dockerfile удобен для быстрого прототипирования и тестирования уде существующих образов* 

`docker run` - команда для запуска контейнера, у нее множество флагов: 
- `-d` запускает контейнер в фоновом режиме без привязки к текущему 
- `-it` запускает контейнер в интерактивном режиме и разрешает взаимодействие с терминалом. Сперва устанавливается интерактивный режим — `-i`, который затем ассоциируется с терминалом — `-t`
- `--name` позволяет задать имя контейнера вместо генерируемого по умолчанию
- `--rm` обеспечивает автоматическое удаление контейнера после того, как он завершает работу 
- `-w (--workdir)` устанавливает текущую рабочую директорию внутри контейнера 
- `-p` пробрасывает порты контейнера на порты хоста 
- `--env` устанавливает переменные среды внутри контейнера 
- `--network` присоединяет контейнер к определенной сети 
- `-v (-volume)` подключает внешнее хранилище — например, том или директорию хоста — к контейнеру при его запуске

***Примеры:*** 

1. ***Вот простой пример запуска контейнера на основе образа Ubuntu в интерактивном режиме:***
- `$ docker run -it ubuntu`

2. ***Результат — возможность взаимодействия с командной строкой внутри контейнера:*** 
- `$ docker run -it ubuntu`

3. ***Здесь мы запускаем контейнер на основе образа NGINX в фоновом режиме, присваиваем ему имя `my_container` и пробрасываем порт `80` контейнера на порт `8080` хоста:***
- `$ docker run -d --name my_container -p 8080:80 nginx`

4. ***Теперь — запуск контейнера с пользовательскими переменными среды:***
- `$ docker run --network=Some_net ubuntu`

5. ***В этом примере запускаем контейнер на основе образа MySQL, устанавливаем переменную среды `MYSQL_ROOT_PASSWORD` и `MYSQL_DATABASE` для настройки базы данных MySQL внутри контейнера:***
- `$ docker run --env MYSQL_ROOT_PASSWORD=pass123 --env MYSQL_DATABASE=mydb mysql`

6. ***Так подключаем контейнер к сети с именем `Some_net`:***
- `$ docker run --network=Some_net ubuntu`

7. ***И запускаем контейнер, подключая к нему локальную директорию `/home/user1/somefolder` по пути `/data`:***
- `docker run --volume=/home/user1/somefolder:/data ubuntu`

***Помимо `docker run` есть и другие команды,, с помощью которых можно взаимодействовать с контейнером:*** 
- `Docker Copy` или `docker cp`. Эта команда позволяет копировать фалы между хостом и контейнеров или между контейнерами 
***Здесь копируем файл `some.txt` с хоста внутрь контейнера `super_container` в директорию `/opt`:***
- `docker cp /local/some.txt super_container:/opt/some.txt`

- `Docker Exec` используется для выполнения команд внутри запущенного контейнера. Так можно запускать дополнительные процессы или выполнять административные задачи в контейнере.
***В этом случае мы выполняем команду MySQL, чтобы создать новую базу данных в контейнере `some_mysql_container`:***
- `docker exec some_mysql_container mysql -uroot -p -e 'CREATE DATABASE new_database;'`

```
FROM node:14

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

CMD ["npm", "start"]
```

***Правильная команда:*** 
`docker run -it --workdir="/usr/src/app" -v "$(pwd):/usr/src/app" node:14 npm start`
- `docker run` - запускает новый контейнер 
- `-it` - предоставляет интерактивную оболочку TTY
- `--workdir="/usr/src/app"` - устанавливает рабочую директорию в контейнере в /usr/src/app
- `-v "$(pwd):/usr/src/app"` - монтирует текущую рабочую директорию хоста внутри контейнера по пути /usr/src/app
- `node:14` - имя образа, который мы хотим запустить 
- `npm start` - команда, которую нужно выполнить внутри контейнера 

*Таким образом, `docker run` будет создавать контейнер из образа `Node.js` и запускать `npm start` из рабочей директории `/usr/src/app`*

```
FROM node:14

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

***Правильная команда:*** 
`docker run -p 3000:3000 -v $(pwd):/usr/src/app -w /usr/src/app -d node:14 npm start`
- `p 3000:3000` — пробрасывает порт `3000` из контейнера на порт `3000` хоста;
- `v $(pwd):/usr/src/app` — монтирует текущую директорию хоста внутри контейнера;
- `w /usr/src/app` — задаёт рабочую директорию в контейнере;
- `d` — запускает контейнер в фоновом режиме;
- `node:14` — имя образа, который мы хотим запустить;
- `npm start` — команда для запуска приложения.
## ***Функции Docker***

- `docker create`- создает новый контейнер, но без запуска. Это позволяет приготовить контейнер, не выполняя его до явной команды docker start 
*К примеру, `docker run -it --name=my_container ubuntu:latest bash` создаёт и запускает контейнер из образа `ubuntu:latest` с оболочкой `bash`, именем контейнера `my_container` и входит в интерактивный режим для взаимодействия с оболочкой.*
- `docker ps` - отображает запущенный контейнер с их ID, именами, статусом и другой информацией 
*Флаг `-a` для этой команды отображает все контейнеры, включая остановленные, а `-q` — только идентификаторы контейнеров.*
- `docker images` - выводит список доступных образов на вашем компьютере, а с флагом a отобразится все, включая промежуточные 
- `docker stop` - останавливает работу запущенного контейнера 
*`docker stop my_container` остановит контейнер с именем `my_container`*
- `docker kill` - отправляет сигнал остановки внутрь контейнера. Это полезно, если docker stop ни к чему не приводит или если нужно немедленно остановить контейнер 
- `docker rm` - удалят контейнеры 
*`docker rm my_container` удалит контейнер с именем `my_container`*
*Флаг `f` удаляет контейнеры принудительно, то есть независимо от их состояния, а `docker rmi` удаляет образы Docker.*
- `docker volume` - управляет Docker-томами, постоянными хранилищами данных 
*`docker volume create my_volume` создаёт новый том с именем `my_volume`. Флаг `ls` выводит список томов Docker*
- `docker network` - управляет сетями Docker 
*команда `docker network ls` отобразит их списком*. *Флаг `create` создаёт новую Docker-сеть, а `inspect` отображает подробную информацию о сети.*
- `docker inspect` - предоставляет подробные данные о контейнерах, образах, сетях или Docker-объектах
*Так, `docker inspect some_container` вернёт информацию о контейнере с именем `some_container`, включая его конфигурацию, сетевые параметры, файлы системы и так далее.*
- `docker pull` - загружает образы Docker из реестра Docker Hub или других
*`docker pull ubuntu:latest` загрузит последний образ Ubuntu из Docker Hub на ваше устройство*
- `docker push` - загружает Docker-образы в Docker Hub или другие реестры
*`docker push user/my_image:tag`, где `user` — имя пользователя на Docker Hub или в другом реестре, `my_image` — название образа, и `tag` — тег, который вам нужно использовать для него, например `latest`*
- `docker commit` - создания нового образа контейнера на основе изменений, которые были внесены в работающий контейнер
*`docker commit my_container my_image:latest` создаст новый образ на основе изменений контейнера `my_container`. И если говорить о флагах: `m` добавляет сообщение к коммиту, `а` — устанавливает автора образа.*

![[Pasted image 20251214112129.png]]

***Docker Compose*** - это инструмент для определения и запуска многоконтейнерных Docker-приложений. Он позволяет определить все зависимости и настройки контейнеров в файле YAML, что делает развертывание и управление приложениями более удобным 
 
***YAML*** - это простой язык разметки, используемый для предоставления данных 

***Основные элементы синтаксиса YAML:*** 
- Отступы (Вложенности обозначаются пробелами, у таких отступов — ключевое значение для определения структуры данных)
- Пары "ключ-значение" (Речь о формате `ключ: значение`, фрагменты которого разделены двоеточием)
- Массивы (Представляются с помощью дефиса и пробела перед каждым элементом массива)

`docker-compose.yml`

```

version: '3'

services:
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
```

- `version: '3'` - сообщает Docker, что файл использует схему версии `3` для определения сервисов и их конфигурации
- `image` - определяет образ контейнера, который будет использоваться для сервиса `prometheus`
- - значение `ports` сообщает, что порт `9090` контейнера будет проброшен на порт `9090` хоста
- `volumes` - монтирует конфигурационный файл `prometheus.yml` внутрь контейнера

```
grafana:
  image: grafana/grafana:latest
  ports:
    - "3000:3000"
  environment:
    - GF_SECURITY_ADMIN_USER=admin
    - GF_SECURITY_ADMIN_PASSWORD=admin
```

- как и в прошлом случае, в `image` мы определяем образ контейнера для веб-интерфейса Grafana
- строка `ports` пробрасывает порт `3000` контейнера на порт `3000` хоста
- `environment` устанавливает переменные окружения для логина и пароля по умолчанию

```
mysql-server:
    image: mysql:latest
    environment:
      - MYSQL_DATABASE=zabbix
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=zabbix_password
      - MYSQL_ROOT_PASSWORD=root_password
    ports:
      - "3306:3306"
```

- `image` определяет образ контейнера для MySQL сервера
- `environment` устанавливает переменные окружения для конфигурации и инициализации базы данных
- `ports` пробрасывает порт `3306` контейнера на порт `3306` хоста для доступа к базе данных

*Эти три сервиса позволяют развернуть систему мониторинга и визуализации данных — например, с использованием Prometheus, Grafana и базы данных MySQL — с помощью одной команды: `docker-compose up`. Благодаря параметрам `ports`, `environment` и `links` мы настраиваем связи и конфигурации для каждого сервиса.*

- `docker-compose up` - запускает все контейнеры, определенные в файле docker-compose.yml
- `docker-compose down` - останавливает и удаляет все контейнеры docker-compose.yml
- `docker-compose ps` - отображает текущий статус контейнеров docker-compose.yml
- `docker-compose build` - собирает или прособирает сервисы, определенные в  docker-compose.yml
- `docker-compose start` - запускает остановленные сервисы, `docker-compose stop` - останавливает запущенные, а `docker-compose restart` перезапускает сервисы
- `docker-compose exec` - запускает команду внутри контейнера, например: `docker-compose exec webserver sh`
- `docker-compose logs` - показывает логи сервисов 
- `docker-compose pull` - вытягивает образы для сервисов из реестра 

