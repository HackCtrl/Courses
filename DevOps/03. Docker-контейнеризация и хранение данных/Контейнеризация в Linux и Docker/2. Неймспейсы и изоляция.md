***NS (namespaces)*** - механизм ОС, обеспечивающий изоляцию системным ресурсов. При этом каждый контейнер получает собственное видимое пространство. При этом контейнеры видят только свои процессы, ФС, сетевые интерфейсы и другие системные атрибуты, отдаленные от других контейнеров и хоста

***NS*** - обеспечивает высокую степень изоляции, безопасности и контроля над ресурсами за счет создания виртуальных сред, где контейнеры работают как автономные сущности, то есть независимо друг от друга. Облегчается и развертывание приложений в независимых и надежных средах

`ip netns` - это инструмент для управления сетевыми пространствами имен в Linux (сетевые пространства имен позволяют создавать изолированные сетевые сетки со своими интерфейсами, маршрутами, таблицами маршрутизации, сокетами и т.д)
## ***Как использовать `ip netns`***

1. Создание и удаление сетевых пространств имен: 
- `ip netns add myns` - создает сетевое пространство имен с именем myns
- `ip netns delete myns` - удаляет сетевое пространство имен myns
2. Управление интерфейсами внутри данных пространств имен: 
- **Вот так можно привязать интерфейс к сетевому пространству имени:**
`ip link add veth0 type veth peer name veth1`
`ip link set veth1 netns myns`
`ip netns exec myns ip link set dev veth1 up`
3. Установка маршрутов и правил маршрутизации внутри сетевого пространства имен: 
`ip link set veth1 netns myns`
`ip netns exec myns ip link set dev veth1 up`

`unshare` - часть утилиты util-linux в Linux. Она позволяет процессу отрываться от некоторых или всех идентификаторов пространства пользователя или имени и создавать так изолированное окружение 
## ***Примеры использования `unshare`***

1. Создание изолированной ФС: 
- `unshare --mount --uts --ipc --net --pid --fork chroot /path/to/rootfs /bin/bash`
2. Создание изолированного пространства имени - PID namespace уникального для каждого процесса: 
- `unshare --pid --fork /bin/bash`
3. Создание изолированного пространства имен пользователя (user namespace)

***Типы NS с примерами их применения***

1. PID Namespace - изоляция процессов 
PID Namespace предоставляет изолированное пространство идентификаторов процессов для каждого контейнера: 
`sudo unshare --pid --fork`
`ps aux`

2. Mount namespace - изоляция ФС
Mount namespace создает изолированное  представление ФС для каждого контейнера: 
`sudo unshare --mount --fork`
`mount --make-rslave /`
`mount --rbind /tmp /mnt`

3. Network namespace - изоляция сетевых ресурсов 
Network namespace изолирует сетевые ресурсы, включая сетевые интерфейсы таблиц маршрутизации, firewall-правила и другие параметры сети: 
`sudo ip netns add ns1`
`sudo ip netns exec ns1 ip link set lo up`
`sudo ip netns exec ns1 ip link`

4. IPC Namespace - изоляция межпроцессорного взаимодействия 
IPC Namespace изолирует межпроцессорное взаимодействие - очереди сообщений и семафоры, что позволяют контейнерам работать в изолированных средах без конфликтов: 
`sudo unshare --ipc --fork`
`ipcs`

5. UTS Namespace - изоляция параметров системы 
UTS Namespace изолирует два параметра: название хоста и доменное имя: 
`sudo unshare --uts --mount --pid --fork`
`echo "newhostname" > /proc/sys/kernel/hostname`
`echo "newhostname" > /proc/sys/kernel/hostname`

6. User namespace - изоляция идентификаторов пользователей
User namespace позволяет изолировать идентификаторы пользователей и групп внутри контейнера. Этим обеспечивается запуск процессов с привилегиями пользователя, безопасно изолированными от основной системы: 
`sudo unshare --user --map-root-user --mount --pid --fork`
## ***Роль `cgroups` в контейнеризации***

***Контрольные группы (`cgroups`)*** - это механизм ядра Linux, предоставляющий функции для ограничения, пиритизации ресурсов (CPU, памяти, ввода-вывода и других) для группы процессов 

1. Управление ресурсами `сgroups` - позволяет ограничивать доступ контейнеров к ресурсам, что обеспечивает их равномерное распределение
2. Изоляция - контейнеры могут работать независимо друг от друга и не конкурировать за ресурсы 
3. Пиритизация - назначая приоритеты ресурсам, контрольные группы могут выделять важные их них конкретным контейнерам. Так обеспечивается их стабильная и предсказуемая работа 

***Рассмотрим пару примеров использования `cgroups` с помощью Docker:***

- **Ограничение ресурсов.** Предположим, у нас есть несколько контейнеров, для которых нужно установить лимит на использование ЦП и памяти. Можно сделать это с помощью `cgroup` и так обеспечить справедливое распределение ресурсов между контейнерами.
- **Изоляция ресурсов.** C `cgroups` каждый контейнер может получить свою долю ресурсов, взаимодействуя напрямую с ядром ОС для контроля и управления ими. Это предотвращает воздействие одного контейнера на ресурсы другого.

***`Seccomp` (Secure Computing Mode)*** - позволяет ограничивать доступ процессов к системным вызовам ядра Linux, что уменьшает поверхность атаки и повышает безопасность контейнеров 

*Например, контейнер может использовать `seccomp` для разрешения конкретных системных вызовов — `read`, `write`, `exit` — и блокировки опасных — `socket`, `setuid` и других.*

**В этом примере опция `seccomp=unconfined` отключает ограничения `seccomp` для контейнера:**
`docker run --security-opt seccomp=unconfined my_container`

`AppArmor` - позволяет определять профили безопасности для контейнеров, ограничивать их доступ к файлам, сетевым ресурсам и другим объектам в ОС хоста 

*Например, можно создать профиль безопасности для контейнера, разрешающий доступ только к определённым каталогам и файлам. Так мы предотвратим доступ к другим частям файловой системы хоста.*

**Здесь `apparmor=my_profile` указывает Docker использовать профиль безопасности `my_profile` для контейнера:**
`docker run --security-opt apparmor=my_profile my_container`

***SELinux*** - обеспечивает дополнительный уровень контроля над доступом к ресурсам и объектам в системе 
## ***Docker***

***Docker*** - это платформа для разработки, доставки и запуска приложений в контейнерах. Он включает пакетный формат для контейнеров, инструменты для создания образов, управление контейнерами и многое другое

***Компоненты Docker***

1. ***Docker Engine*** - основной компонент Docker, состоящий из нескольких подсистем, обеспечивающих выполнение контейнеров и управление ими 

***Его подсистемы:*** 
- ***Docker Daemon*** - фоновый процесс, или демон, который управляет жизненным циклом контейнеров, включая их создание, выполнение, остановку и удаление. За все это отвечает модуль Container Runtime (*Другие задачи этого процесса - управление контейнерами образами, сетевыми интерфейсами, хранилищем и другими компонентами, связанными с контейнерами*)
`containerd` и `runc` - в большинстве случаев используется для запуска рантайма контейнеров и управление их жизненным циклом 
- ***Docker CLI*** - интерфейс командной строки, через который пользователи взаимодействуют с Docker Daemon с помощью команд. С ним можно создавать и масштабировать контейнеры, управлять ими и сетями, работать с образами Docker, объединять контейнеры в приложение 

2. ***Docker Images*** - шаблоны, на основе которых создаются контейнеры. Они включают в себя все необходимое для запуска приложения, включая ФС, среду выполнения и другие зависимости 

3. ***Docker Registries*** - хранилище образов Docker, где образы могут сохраняться, обмениваться и загружаться из них, К популярным поблочным Docker-репозиториям относится Docker Hub, так же организации могут запускать собственные частные репозитории для управления образами 

4. ***Docker Networks*** - предоставляют контейнерам возможность общаться друг с другом и с внешней сетью. Docker обеспечивает различные типы сетей для изолированных или связанных сетевых сред для контейнеров 

***Основное про Docker:*** 
- Удобство использования 
- Обширное сообщество 

***Другие важные инструменты***
## ***Podman***

***Podman*** - это инструмент для управления контейнерами и изоляция процессов в Linux 

***Его компоненты:*** 
- ***Podman Engine*** - альтернатива Docker Engine, обеспечивающая управление жизненным циклом контейнеров без использования демона 
- ***Podman CLI*** - интерфейс командной строки для взаимодействие с Podman Engine

***Основы про Podman:***
- Без демона 
- Совместимость с Docker 
## ***LXD***

***LXD*** - это система управления контейнерами для Linux, поэтому ее фокус - на предоставлении высококровного интерфейса для управления ими и обеспечении виртуализации на уровне системы 

*LXD построен поверх технологии **LXC** — технологии виртуализации на уровне системы для Linux.*

***Составляющие LXD:***
- ***LXD Daemon*** - для управления контейнерами и виртуальными машинами 
- ***LXD Client*** - интерфейс командной строки для взаимодействия с LXD Daemon

***Основы LXD:***
- Управление контейнерами как виртуальными машинами 
- Простота использования и интеграция с существующими системами управления виртуализацией 
## ***Container Runtime***

***Container Runtimes*** - компоненты, выполняющие техническую работу по управлению контейнерами и их исполнению. Они отвечают за загрузку образов контейнеров, их создание, управление внутренними процессами и мониторинг 

***Контейнерные оркестраторы*** - это инструменты, которые помогают управлять работой множества контейнеров и координировать их работу в масштабе кластера 

*Разница между Docker и Container Runtimes в том, что Docker — это платформа для разработки, доставки и запуска приложений в контейнерах. Docker предоставляет целый набор инструментов и компонентов, включая Container Runtimes.*

***Преимущества Container Runtimes:***
1. Гибкость 
2. Легковесность по сравнению с Docker 
3. Простота для установки, настройки и обслуживании 

***Основные инструменты***
1. `runc` - инструмент с открытым исходным кодом, разработанный по стандартам OCI (Open Container Initiative). Он обеспечивает минимальную реализацию контейнерного интерфейса, которая позволяет создавать и запускать контейнеры, управлять ими.
2. LXC - система изоляции процессов на уровне ОС Linux, предоставляющая легковесное виртуализированное окружение для запуска приложений в изолированных контейнерах. (собственный инструментарий - `lxc-start`, `lxc-stop`)
3. `containerd` - проект с открытым исходным кодом, который служит в качестве ядра контейнерных рантаймов для Docker. Одна из его основных задач — распределённый контроль над контейнерами и управление ресурсами между ними.
4. `rkt` - контейнерный рантайм с открытым исходным кодом, разработанный CoreOS. Он поддерживает самостоятельное управление и запуск контейнеров без зависимостей от инструментов управления кластером.
5. `cri-o` - также проект с открытым исходным кодом, разработанный прежде всего для интеграции с Kubernetes. Он предоставляет компоненты контейнерного рантайма, которые реализуют спецификацию CRI (Container Runtime Interface).

## ***Что нужно знать о безопасности в контейнеризации***

***Основные уязвимости***
1. Уязвимости ядра 
2. Привилегии и управление доступом 
3. Недостаточная защита от DoS-атак
4. Недостатки в параметров конфигурации контейнеров
5. Управление образами и репозиториями контейнеров 

***Снизить риски безопасности в контейнеризации помогут несколько правил:*** 
- регулярно обновлять и патчировать ядра ОС и компоненты контейнерной инфраструктуры;
- использовать механизмы управления доступом (например, RBAC) для контроля привилегий внутри контейнеров;
- обеспечивать адекватную защиту сетевой инфраструктуры и ресурсов для предотвращения DoS-атак;
- внедрять конфигурационные сканирования и контроль безопасности для образов и контейнеров;
- использовать механизмы мониторинга и регистрации для обнаружения нежелательной активности в контейнерах.


