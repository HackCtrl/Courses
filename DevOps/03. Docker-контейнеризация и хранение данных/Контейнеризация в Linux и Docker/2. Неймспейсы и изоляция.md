***NS (namespaces)*** - механизм ОС, обеспечивающий изоляцию системным ресурсов. При этом каждый контейнер получает собственное видимое пространство. При этом контейнеры видят только свои процессы, ФС, сетевые интерфейсы и другие системные атрибуты, отдаленные от других контейнеров и хоста

***NS*** - обеспечивает высокую степень изоляции, безопасности и контроля над ресурсами за счет создания виртуальных сред, где контейнеры работают как автономные сущности, то есть независимо друг от друга. Облегчается и развертывание приложений в независимых и надежных средах

`ip netns` - это инструмент для управления сетевыми пространствами имен в Linux (сетевые пространства имен позволяют создавать изолированные сетевые сетки со своими интерфейсами, маршрутами, таблицами маршрутизации, сокетами и т.д)
## ***Как использовать `ip netns`***

1. Создание и удаление сетевых пространств имен: 
- `ip netns add myns` - создает сетевое пространство имен с именем myns
- `ip netns delete myns` - удаляет сетевое пространство имен myns
2. Управление интерфейсами внутри данных пространств имен: 
- **Вот так можно привязать интерфейс к сетевому пространству имени:**
`ip link add veth0 type veth peer name veth1`
`ip link set veth1 netns myns`
`ip netns exec myns ip link set dev veth1 up`
3. Установка маршрутов и правил маршрутизации внутри сетевого пространства имен: 
`ip link set veth1 netns myns`
`ip netns exec myns ip link set dev veth1 up`

`unshare` - часть утилиты util-linux в Linux. Она позволяет процессу отрываться от некоторых или всех идентификаторов пространства пользователя или имени и создавать так изолированное окружение 
## ***Примеры использования `unshare`***

1. Создание изолированной ФС: 
- `unshare --mount --uts --ipc --net --pid --fork chroot /path/to/rootfs /bin/bash`
2. Создание изолированного пространства имени - PID namespace уникального для каждого процесса: 
- `unshare --pid --fork /bin/bash`
3. Создание изолированного пространства имен пользователя (user namespace)

***Типы NS с примерами их применения***

1. PID Namespace - изоляция процессов 
PID Namespace предоставляет изолированное пространство идентификаторов процессов для каждого контейнера: 
`sudo unshare --pid --fork`
`ps aux`

2. Mount namespace - изоляция ФС
Mount namespace создает изолированное  представление ФС для каждого контейнера: 
`sudo unshare --mount --fork`
`mount --make-rslave /`
`mount --rbind /tmp /mnt`

3. Network namespace - изоляция сетевых ресурсов 
Network namespace изолирует сетевые ресурсы, включая сетевые интерфейсы таблиц маршрутизации, firewall-правила и другие параметры сети: 
`sudo ip netns add ns1`
`sudo ip netns exec ns1 ip link set lo up`
`sudo ip netns exec ns1 ip link`

4. IPC Namespace - изоляция межпроцессорного взаимодействия 
IPC Namespace изолирует межпроцессорное взаимодействие - очереди сообщений и семафоры, что позволяют контейнерам работать в изолированных средах без конфликтов: 
`sudo unshare --ipc --fork`
`ipcs`

5. UTS Namespace - изоляция параметров системы 
UTS Namespace изолирует два параметра: название хоста и доменное имя: 
`sudo unshare --uts --mount --pid --fork`
`echo "newhostname" > /proc/sys/kernel/hostname`
`echo "newhostname" > /proc/sys/kernel/hostname`

6. User namespace - изоляция идентификаторов пользователей
User namespace позволяет изолировать идентификаторы пользователей и групп внутри контейнера. Этим обеспечивается запуск процессов с привилегиями пользователя, безопасно изолированными от основной системы: 
`sudo unshare --user --map-root-user --mount --pid --fork`
## ***Роль `cgroups` в контейнеризации***

***Контрольные группы (`cgroups`)*** - это механизм ядра Linux, предоставляющий функции для ограничения, пиритизации ресурсов (CPU, памяти, ввода-вывода и других) для группы процессов 

1. Управление ресурсами `сgroups` - позволяет ограничивать доступ контейнеров к ресурсам, что обеспечивает их равномерное распределение
2. Изоляция - контейнеры могут работать независимо друг от друга и не конкурировать за ресурсы 
3. Пиритизация - назначая приоритеты ресурсам, контрольные группы могут выделять важные их них конкретным контейнерам. Так обеспечивается их стабильная и предсказуемая работа 

***Рассмотрим пару примеров использования `cgroups` с помощью Docker:***

- **Ограничение ресурсов.** Предположим, у нас есть несколько контейнеров, для которых нужно установить лимит на использование ЦП и памяти. Можно сделать это с помощью `cgroup` и так обеспечить справедливое распределение ресурсов между контейнерами.
- **Изоляция ресурсов.** C `cgroups` каждый контейнер может получить свою долю ресурсов, взаимодействуя напрямую с ядром ОС для контроля и управления ими. Это предотвращает воздействие одного контейнера на ресурсы другого.

***`Seccomp` (Secure Computing Mode)*** - позволяет ограничивать доступ процессов к системным вызовам ядра Linux, что уменьшает поверхность атаки и повышает безопасность контейнеров 

*Например, контейнер может использовать `seccomp` для разрешения конкретных системных вызовов — `read`, `write`, `exit` — и блокировки опасных — `socket`, `setuid` и других.*

**В этом примере опция `seccomp=unconfined` отключает ограничения `seccomp` для контейнера:**
`docker run --security-opt seccomp=unconfined my_container`

`AppArmor` - позволяет определять профили безопасности для контейнеров, ограничивать их доступ к файлам, сетевым ресурсам и другим объектам в ОС хоста 

*Например, можно создать профиль безопасности для контейнера, разрешающий доступ только к определённым каталогам и файлам. Так мы предотвратим доступ к другим частям файловой системы хоста.*

**Здесь `apparmor=my_profile` указывает Docker использовать профиль безопасности `my_profile` для контейнера:**
`docker run --security-opt apparmor=my_profile my_container`

***SELinux*** - обеспечивает дополнительный уровень контроля над доступом к ресурсам и объектам в системе 
## ***Docker***

***Docker*** - 