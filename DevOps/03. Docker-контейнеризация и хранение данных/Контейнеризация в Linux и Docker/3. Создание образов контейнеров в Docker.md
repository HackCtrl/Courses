***Dockerfile*** - это текстовый файл с набором инструкций о том, как Docker должен собрать образ контейнера 

***Образ контейнера*** - это статичный шаблон со всеми необходимыми для запуска приложения в контейнере, включая ОС, приложение, библиотеки, исходные коды и настройки 

***Контейнер*** - это запущенный экземпляр образа контейнера, в которой можно вносить изменения. Говоря иначе, это изолированные среды, включающие приложение и его зависимости 

***Чтобы собрать и запустить приложение в контейнере:*** 
- Создать Dockerfile 
- На его основе собрать образ 
- Запустить контейнер из этого образа 

***Dockerfile*** - это инструкция по сборке кресла 
***Образ контейнера*** - готовое кресло 
***Контейнер*** - кресло, которое используется 

***Что входит в состав образа контейнера:*** 
1. Слои ФС 
2. Метаданные 

*Для объединения слоёв ФС в Docker используется OverlayFS*

***OverlayFS (Overlay File System — «наложенная файловая система»)*** - это технология объединения ФС, комбинирующая их в одну. Так, Docker может объединить изменения из разных слоев ФС в одно целое представление 

***Создание простого образа Docker***

`docker build -t superweb3000:0.1 .`

***Немного о её компонентах:***
- `docker build` — команда для сборки образа;
- `-t` позволяет задать тег (имя) для образа, чтобы его было просто идентифицировать в будущем;
- `superweb3000:0.1` — имя и версия (тег) нашего образа. Обычно в Docker образы именуются в формате `<имя образа>:<тег>`;
- `.` сообщает Docker, что нужно использовать текущий каталог в качестве контекста сборки.

`docker run -d -p 865:80 superweb3000:0.1` 

***Немного о её компонентах:***
`-d` позволяет контейнеру работать в фоновом режиме, а `-p 865:80` указывает на проброс портов. Контейнер будет слушать порт `80,` а мы — обращаться к нему через порт `865` на хосте

***Buildah*** - это утилита командной строки, которая упрощает создание контейнеров и управление их образами 

Работая с ней, мы начали бы с создания нового контейнера на основе образа Nginx с помощью `buildah from`.

```
buildah from nginx 
```

Затем с помощью `buildah copy` скопировали бы файл `index.html` внутрь контейнера

```
buildah copy mycontainer index.html /usr/share/nginx/html/index.html 
```

И с помощью `buildah commit` сохранили изменения в новый образ с именем `superweb3000`.

```
buildah commit mycontainer superweb3000
 
```

## ***Заполнение Dockerfile***
 
`.dockerignore` - может располагаться в одной папке с Dockerfile. Он указывает, какие файлы и директории нужно игнорировать при копировании файлов в образ. (Он позволяет уменьшить размер контекста сборки и повысить ее скорость, избежать включение ненужных файлов в образ)

```
# comment
    */prov*
    */*/prov*
    prov?
   *.log
    !some.log 
```

- `# comment` игнорируется, так как всё, что идёт после знака `#`, считается комментарием;
- `/prov*` исключает файлы и каталоги, имена которых начинаются с `prov` в любой поддиректории корневой папки;
- `/*/prov*` исключает файлы и каталоги c именами, начинающимися с `prov`, во всех каталогах второго уровня;
- `prov?` исключает файлы и папки в корневой директории, имена которых отличаются на один символ от `prov`;
- `.log` исключает все файлы с расширением `log`;
- `!some.log` исключает файл `some.log` из предыдущего правила.
#### ***Инструкции внутри Dockerfile***

- `FROM` - обязательная инструкция для начала каждого Dockerfile (исключение~~м~~ — только инструкция ARG)
- `LABEL` - добавляет метаданные к образу (описание, версию, лицензию и так далее)

`LABEL version="4.0" description="Some description"`- В этом примере мы добавляем метаданные к образу, указываем его версию и описание

`COPY` - копирование файлов с хоста в контейнер 

`COPY . /app` - Здесь мы копируем все файлы из текущей директории хоста внутрь контейнера в `/app`

`ADD` - включает все функции COPY, но дополнительно может обрабатывать URL и автоматически распаковывать архивные файлы в формате tar 

`ADD source_folder /destination_folder` - Так, содержимое `source_folder` копируется внутрь образа в `destination_folder`

`WORKDIR` - устанавливает рабочую директорию внутри контейнера 

`WORKDIR /app` - Здесь это происходит в `/app`

`VOLUME` - позволяет контейнеру создавать точки монтирования для хранения информации 

`VOLUME /somedata` - В этом примере мы создаём точку монтирования с именем `/somedata`. Теперь все данные, сохранённые внутри `/somedata` в контейнере, будут сохранены в указанной директории на хосте

`RUN` - выполняет команды в контейнере во время сборки образа 

`RUN apt-get update && apt-get install -y python3` - Рассмотрим пример обновления списка пакетов и установки Python 3 в контейнере. Символ `&&` в нём соединяет две команды и требует успешного выполнения первой для выполнения второй — это называется логическим «И»

`CMD` - устанавливает команду, которая будет выполняться при запуске контейнера из созданного образа. Эту инструкцию можно использовать в Dockerfile один раз, и, если вы используете больше одной CMD, работать будет только последняя 

`CMD ["python", "app.py"]` - В этом примере `CMD` устанавливает команду для запуска Python-приложения `app.py` при запуске контейнера

`ENTRYPOINT` - задает исполняемую команду, которая будет активироваться при запуске контейнера. Так же она используется один раз 

`ENTRYPOINT ["nginx", "-g", "daemon off;"]` - Команда с параметром `daemon off` запустит контейнер в режиме foreground. Это критически важно в контейнерной среде, так как если основной процесс перейдёт в фон, то контейнер остановится сразу после запуска

`RUN` используется во время сборки образа, `CMD` устанавливает команду по умолчанию для запуска контейнера, которую можно переопределить. `ENTRYPOINT` тоже устанавливает команду для запуска контейнера, но без возможности переопределения 

`EXPOSE` - открывает указанные порты в контейнере без их фактического проброса на хост-систему. Это нужно для документирования, какие их них должны быть доступными для взаимодействия с внешними системами 

`EXPOSE 80`

***Коротко обсудим команды `ENV` и `ARG`***

`ENV` - позволяют устанавливать переменные окружения в контейнере, которые будут доступны приложению внутри него 

***Переменные окружения в контейнере*** - это специальные значения, которые могут быть установлены и доступны для использования в пределах контейнера 

Рассмотрим простой пример с использованием инструкции `ENV`. Предположим, у нас есть приложение, которое зависит от адреса, порта базы данных и ключа API. Используем `ENV` для установки этих значений внутри контейнера Docker:

```
# Пример использования инструкции ENV
ENV DB_ADDRESS=mysql.some.site
ENV DB_PORT=3306
ENV API_KEY=some_api_key 
```

Инструкция `ARG` в Dockerfile определяет аргументы, которые могут быть переданы при сборке образа: `ARG <name>[=<some value>]`

`ARG` - переменные недоступны в контейнере во время его выполнения, а `ENV` - переменные задаются как раз во время выполнения 

***Допустим, у нас есть Dockerfile:***

```
# Использование ARG для передачи переменной извне в Dockerfile
ARG APP_VERSION=latest

# Использование значения ARG для установки ENV-переменной с тем же значением
ENV APP_VERSION=${APP_VERSION} 
```

При запуске команды сборки Docker-образа можно передать значение переменной извне, используя флаг `--build-arg <varname>=<value>`:

```
docker build --build-arg APP_VERSION=1.0 -t superapp:1.0 . 
```

